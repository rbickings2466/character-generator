import { GoogleGenAI } from "@google/genai";
import { MohoCharacterAttributes, BodyPart, ViewAngle, ReferenceSheet, PartViewKey } from "../types";
import { buildReferencePrompt, buildPartPrompt } from "../utils/prompts";
import { ALL_PART_VIEW_KEYS, parsePartViewKey } from "../constants/bodyParts";
import { API_CONFIG, GEMINI_MODELS } from "../constants/api";
import { logger } from "../utils/logger";
import { compressImage } from "./imageProcessor";
import { getCachedPart, cachePart } from "../utils/cache";

// Type definitions for Gemini API response
interface GeminiInlineData {
  data?: string;
  mimeType?: string;
}

interface GeminiPart {
  text?: string;
  inlineData?: GeminiInlineData;
}

interface GeminiContent {
  parts?: GeminiPart[];
}

interface GeminiCandidate {
  content?: GeminiContent;
}

interface GeminiResponse {
  candidates?: GeminiCandidate[];
}

// Singleton API client - created once, reused for all requests
let aiClient: GoogleGenAI | null = null;

const getAIClient = (): GoogleGenAI => {
  if (!aiClient) {
    aiClient = new GoogleGenAI({ apiKey: process.env.API_KEY || '' });
  }
  return aiClient;
};

// Helper to extract image from Gemini response
const extractImageFromResponse = (response: GeminiResponse): string => {
  const parts = response.candidates?.[0]?.content?.parts;
  if (!parts) {
    throw new Error("No image generated by the model.");
  }

  for (const part of parts) {
    if (part.inlineData?.data) {
      return `data:image/png;base64,${part.inlineData.data}`;
    }
  }

  throw new Error("Could not find image data in response.");
};

// Generate the reference sheet (two views for consistency)
export const generateReferenceSheet = async (
  attrs: MohoCharacterAttributes
): Promise<ReferenceSheet> => {
  const ai = getAIClient();

  const prompt = buildReferencePrompt(attrs);

  try {
    const response = await ai.models.generateContent({
      model: GEMINI_MODELS.REFERENCE_SHEET,
      contents: { parts: [{ text: prompt }] },
      config: {
        responseModalities: ['IMAGE', 'TEXT']
      }
    });

    const imageUrl = extractImageFromResponse(response);

    return {
      imageUrl,
      generatedAt: Date.now()
    };
  } catch (error) {
    logger.error("Gemini Reference Generation Error:", error);
    throw error;
  }
};

// Generate a single isolated body part
export const generateBodyPart = async (
  attrs: MohoCharacterAttributes,
  part: BodyPart,
  view: ViewAngle,
  referenceImage: string
): Promise<string> => {
  const ai = getAIClient();

  const prompt = buildPartPrompt(attrs, part, view);

  // Use image-to-image with reference for consistency
  const referenceData = referenceImage.split(',')[1];
  const mimeType = referenceImage.includes('image/jpeg') ? 'image/jpeg' : 'image/png';

  try {
    const response = await ai.models.generateContent({
      model: GEMINI_MODELS.BODY_PART,
      contents: {
        parts: [
          {
            inlineData: {
              data: referenceData,
              mimeType
            }
          },
          { text: prompt }
        ]
      },
      config: {
        responseModalities: ['IMAGE', 'TEXT']
      }
    });

    return extractImageFromResponse(response);
  } catch (error) {
    logger.error(`Gemini Part Generation Error (${part}_${view}):`, error);
    throw error;
  }
};

// Helper to delay execution
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Batch generation with rate limiting - sequential to avoid API limits
export const generateAllParts = async (
  attrs: MohoCharacterAttributes,
  referenceImage: string,
  onPartStarted: (key: PartViewKey) => void,
  onPartComplete: (key: PartViewKey, imageUrl: string) => void,
  onPartError: (key: PartViewKey, error: string) => void,
  _concurrency: number = 1
): Promise<void> => {
  const queue = [...ALL_PART_VIEW_KEYS];

  // Compress reference image once for all API calls
  const compressedReference = await compressImage(referenceImage);
  logger.log('Reference image compressed for API optimization');

  for (const key of queue) {
    const { bodyPart, viewAngle } = parsePartViewKey(key);

    onPartStarted(key);

    // Check cache first
    const cachedImage = getCachedPart(attrs, key);
    if (cachedImage) {
      logger.log(`Using cached image for ${key}`);
      onPartComplete(key, cachedImage);
      continue;
    }

    let success = false;
    let lastError = '';

    // Try up to MAX_RETRY_ATTEMPTS times with increasing delays
    for (let attempt = 0; attempt < API_CONFIG.MAX_RETRY_ATTEMPTS && !success; attempt++) {
      try {
        if (attempt > 0) {
          logger.log(`Retry attempt ${attempt + 1} for ${key}`);
          await delay(API_CONFIG.RETRY_DELAY_MS * attempt);
        }
        const imageUrl = await generateBodyPart(attrs, bodyPart, viewAngle, compressedReference);

        // Cache the result
        cachePart(attrs, key, imageUrl);

        onPartComplete(key, imageUrl);
        success = true;
      } catch (error) {
        lastError = error instanceof Error ? error.message : 'Unknown error';
        logger.warn(`Attempt ${attempt + 1} failed for ${key}:`, lastError);
      }
    }

    if (!success) {
      onPartError(key, lastError);
    }

    // Wait between requests to avoid rate limiting (skip if cached)
    if (!cachedImage) {
      await delay(API_CONFIG.REQUEST_DELAY_MS);
    }
  }
};
